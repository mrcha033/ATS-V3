#pragma once

#include "data_loader.hpp"
#include "performance_metrics.hpp"
#include <functional>
#include <thread>
#include <atomic>
#include <queue>
#include <memory>
#include <mutex>

namespace ats {
namespace backtest {

// Strategy interface for backtesting
class BacktestStrategy {
public:
    virtual ~BacktestStrategy() = default;
    
    // Strategy initialization
    virtual bool initialize(const std::unordered_map<std::string, std::string>& parameters) = 0;
    
    // Process market data and generate signals
    virtual void on_market_data(const MarketDataPoint& data) = 0;
    
    // Strategy-specific trade logic
    virtual std::vector<TradeSignal> generate_signals(
        const std::vector<MarketDataPoint>& historical_data,
        const MarketDataPoint& current_data) = 0;
    
    // Strategy metadata
    virtual std::string get_strategy_name() const = 0;
    virtual std::string get_strategy_description() const = 0;
    virtual std::vector<std::string> get_required_parameters() const = 0;
    
    // Position sizing
    virtual double calculate_position_size(const TradeSignal& signal, 
                                          double available_capital,
                                          double current_price) = 0;
    
    // Risk management hooks
    virtual bool should_exit_position(const Position& position, 
                                     const MarketDataPoint& current_data) = 0;
    
protected:
    std::string strategy_name_;
    std::unordered_map<std::string, std::string> parameters_;
};

// Trade signal generated by strategy
struct TradeSignal {
    std::chrono::system_clock::time_point timestamp;
    std::string symbol;
    std::string exchange;
    std::string signal_type; // "buy", "sell", "close_long", "close_short"
    double target_price = 0.0;
    double stop_loss = 0.0;
    double take_profit = 0.0;
    double confidence = 1.0; // 0.0 to 1.0
    std::string reason;      // Strategy-specific reason
    std::unordered_map<std::string, double> metadata;
    
    TradeSignal() = default;
    TradeSignal(std::chrono::system_clock::time_point ts, const std::string& sym,
               const std::string& exch, const std::string& type, double price)
        : timestamp(ts), symbol(sym), exchange(exch), signal_type(type), target_price(price) {}
};

// Position tracking
struct Position {
    std::string symbol;
    std::string exchange;
    std::string side; // "long" or "short"
    double quantity = 0.0;
    double entry_price = 0.0;
    std::chrono::system_clock::time_point entry_time;
    double unrealized_pnl = 0.0;
    double stop_loss = 0.0;
    double take_profit = 0.0;
    std::string strategy_name;
    
    Position() = default;
    Position(const std::string& sym, const std::string& exch, const std::string& side_val,
            double qty, double price, std::chrono::system_clock::time_point entry)
        : symbol(sym), exchange(exch), side(side_val), quantity(qty), 
          entry_price(price), entry_time(entry) {}
    
    void update_unrealized_pnl(double current_price) {
        if (side == "long") {
            unrealized_pnl = (current_price - entry_price) * quantity;
        } else {
            unrealized_pnl = (entry_price - current_price) * quantity;
        }
    }
};

// Backtest configuration
struct BacktestConfig {
    // Time period
    std::chrono::system_clock::time_point start_date;
    std::chrono::system_clock::time_point end_date;
    
    // Capital and fees
    double initial_capital = 100000.0;
    double commission_rate = 0.001; // 0.1%
    double spread_cost = 0.0001;    // 0.01%
    double slippage_rate = 0.0001;  // 0.01%
    
    // Risk management
    double max_position_size = 0.1;   // 10% of capital per position
    double max_total_exposure = 0.8;  // 80% maximum total exposure
    double stop_loss_percentage = 0.02; // 2% stop loss
    
    // Execution settings
    std::string execution_model = "simple"; // "simple", "realistic", "advanced"
    bool allow_short_selling = true;
    bool compound_returns = true;
    
    // Performance settings
    int max_threads = std::thread::hardware_concurrency();
    bool enable_progress_callback = true;
    bool detailed_logging = false;
    
    // Data settings
    std::string data_frequency = "1m"; // 1m, 5m, 1h, 1d
    bool require_complete_data = true;
    bool fill_missing_data = true;
};

// Backtest results
struct BacktestResult {
    PerformanceMetrics performance;
    std::vector<TradeResult> trades;
    std::vector<PortfolioSnapshot> portfolio_history;
    std::vector<Position> final_positions;
    PerformanceAttribution attribution;
    
    // Execution statistics
    int total_signals_generated = 0;
    int signals_executed = 0;
    int signals_rejected = 0;
    double execution_rate = 0.0;
    
    // Timing information
    std::chrono::milliseconds execution_time{0};
    std::chrono::system_clock::time_point backtest_start_time;
    std::chrono::system_clock::time_point backtest_end_time;
    
    // Data quality
    DataLoader::DataQualityReport data_quality;
    
    // Error information
    std::vector<std::string> warnings;
    std::vector<std::string> errors;
};

// Progress callback for long-running backtests
struct BacktestProgress {
    std::chrono::system_clock::time_point current_date;
    double progress_percentage = 0.0;
    int processed_data_points = 0;
    int total_data_points = 0;
    int trades_executed = 0;
    double current_portfolio_value = 0.0;
    std::string current_status;
    std::chrono::milliseconds elapsed_time{0};
    std::chrono::milliseconds estimated_remaining{0};
};

using ProgressCallback = std::function<void(const BacktestProgress&)>;

// Main backtest engine
class BacktestEngine {
public:
    BacktestEngine();
    ~BacktestEngine();
    
    // Configuration
    void set_config(const BacktestConfig& config);
    BacktestConfig get_config() const;
    
    // Strategy management
    void add_strategy(std::shared_ptr<BacktestStrategy> strategy);
    void remove_strategy(const std::string& strategy_name);
    std::vector<std::string> get_strategy_names() const;
    
    // Data management
    void set_data_loader(std::shared_ptr<DataLoader> data_loader);
    bool load_market_data(const std::vector<std::string>& symbols,
                         const std::vector<std::string>& exchanges);
    
    // Execute backtest
    BacktestResult run_backtest();
    BacktestResult run_backtest_parallel(); // Multi-threaded version
    
    // Real-time backtest (for paper trading)
    void start_live_backtest();
    void stop_live_backtest();
    bool is_live_backtest_running() const;
    
    // Progress monitoring
    void set_progress_callback(ProgressCallback callback);
    
    // Performance optimization
    void enable_data_caching(bool enable = true);
    void set_memory_limit(size_t max_memory_mb);
    void optimize_for_speed(); // Reduces accuracy slightly for better performance
    void optimize_for_accuracy(); // Maximum accuracy, slower execution
    
    // Results analysis
    std::vector<BacktestResult> run_parameter_sweep(
        const std::string& strategy_name,
        const std::unordered_map<std::string, std::vector<std::string>>& parameter_ranges);
    
    BacktestResult run_monte_carlo_simulation(int num_simulations = 1000);
    
    // Validation and debugging
    bool validate_data_integrity();
    std::vector<std::string> get_validation_warnings() const;
    void enable_debug_mode(bool enable = true);
    
    // Export functionality
    bool export_results_to_csv(const BacktestResult& result, const std::string& directory);
    bool export_detailed_log(const BacktestResult& result, const std::string& file_path);
    
private:
    BacktestConfig config_;
    std::shared_ptr<DataLoader> data_loader_;
    std::vector<std::shared_ptr<BacktestStrategy>> strategies_;
    ProgressCallback progress_callback_;
    
    // Market data storage
    std::vector<MarketDataPoint> market_data_;
    std::unordered_map<std::string, std::vector<MarketDataPoint>> symbol_data_;
    
    // Execution state
    std::atomic<bool> is_running_{false};
    std::atomic<bool> should_stop_{false};
    std::atomic<bool> live_backtest_running_{false};
    
    // Performance optimization
    bool data_caching_enabled_ = true;
    size_t max_memory_mb_ = 1024;
    bool speed_optimized_ = false;
    bool debug_mode_ = false;
    
    // Threading
    std::vector<std::thread> worker_threads_;
    std::mutex data_mutex_;
    std::mutex result_mutex_;
    
    // Core execution methods
    BacktestResult execute_single_threaded();
    BacktestResult execute_multi_threaded();
    
    // Trade execution simulation
    struct ExecutionContext {
        std::vector<Position> positions;
        double available_capital;
        double total_portfolio_value;
        std::vector<TradeResult> completed_trades;
        std::vector<PortfolioSnapshot> portfolio_snapshots;
        int processed_signals;
        int rejected_signals;
    };
    
    bool execute_signal(const TradeSignal& signal, 
                       const MarketDataPoint& market_data,
                       ExecutionContext& context);
    
    void update_positions(const MarketDataPoint& market_data, 
                         ExecutionContext& context);
    
    void check_stop_losses_and_take_profits(const MarketDataPoint& market_data,
                                           ExecutionContext& context);
    
    // Portfolio management
    double calculate_position_size(const TradeSignal& signal, double available_capital);
    double calculate_transaction_costs(double trade_value);
    double apply_slippage(double target_price, const std::string& side);
    
    // Risk management
    bool check_risk_limits(const TradeSignal& signal, const ExecutionContext& context);
    bool exceeds_position_limit(const TradeSignal& signal, const ExecutionContext& context);
    bool exceeds_exposure_limit(const TradeSignal& signal, const ExecutionContext& context);
    
    // Data processing helpers
    void preprocess_market_data();
    std::vector<MarketDataPoint> get_historical_window(
        const std::string& symbol, 
        std::chrono::system_clock::time_point end_time,
        int window_size) const;
    
    // Performance monitoring
    void update_progress(const BacktestProgress& progress);
    std::chrono::milliseconds estimate_remaining_time(double progress_percentage,
                                                     std::chrono::milliseconds elapsed);
    
    // Validation helpers
    bool validate_config() const;
    bool validate_market_data() const;
    bool validate_strategies() const;
    
    // Memory management
    void manage_memory_usage();
    size_t get_current_memory_usage() const;
    
    // Logging and debugging
    void log_trade_execution(const TradeSignal& signal, const TradeResult* result);
    void log_position_update(const Position& position, const MarketDataPoint& data);
    
    // Statistical analysis helpers
    std::vector<double> bootstrap_returns(const std::vector<TradeResult>& trades, 
                                        int num_samples = 1000);
};

// Built-in strategy implementations

// Simple arbitrage strategy
class ArbitrageStrategy : public BacktestStrategy {
public:
    ArbitrageStrategy();
    ~ArbitrageStrategy() override = default;
    
    bool initialize(const std::unordered_map<std::string, std::string>& parameters) override;
    void on_market_data(const MarketDataPoint& data) override;
    std::vector<TradeSignal> generate_signals(
        const std::vector<MarketDataPoint>& historical_data,
        const MarketDataPoint& current_data) override;
    
    std::string get_strategy_name() const override { return "Arbitrage"; }
    std::string get_strategy_description() const override { 
        return "Cross-exchange arbitrage strategy"; 
    }
    std::vector<std::string> get_required_parameters() const override;
    
    double calculate_position_size(const TradeSignal& signal, 
                                  double available_capital,
                                  double current_price) override;
    
    bool should_exit_position(const Position& position, 
                             const MarketDataPoint& current_data) override;
    
private:
    double min_spread_threshold_ = 0.005; // 0.5%
    double max_position_size_ = 0.1;      // 10% of capital
    std::chrono::milliseconds max_hold_time_{300000}; // 5 minutes
    
    // Price tracking for arbitrage detection
    std::unordered_map<std::string, std::unordered_map<std::string, double>> latest_prices_; // symbol -> exchange -> price
    std::unordered_map<std::string, std::chrono::system_clock::time_point> last_update_time_;
    
    bool detect_arbitrage_opportunity(const MarketDataPoint& data,
                                     std::string& buy_exchange,
                                     std::string& sell_exchange,
                                     double& spread_percentage);
};

// Moving average crossover strategy
class MovingAverageCrossoverStrategy : public BacktestStrategy {
public:
    MovingAverageCrossoverStrategy();
    ~MovingAverageCrossoverStrategy() override = default;
    
    bool initialize(const std::unordered_map<std::string, std::string>& parameters) override;
    void on_market_data(const MarketDataPoint& data) override;
    std::vector<TradeSignal> generate_signals(
        const std::vector<MarketDataPoint>& historical_data,
        const MarketDataPoint& current_data) override;
    
    std::string get_strategy_name() const override { return "MA_Crossover"; }
    std::string get_strategy_description() const override { 
        return "Moving Average Crossover Strategy"; 
    }
    std::vector<std::string> get_required_parameters() const override;
    
    double calculate_position_size(const TradeSignal& signal, 
                                  double available_capital,
                                  double current_price) override;
    
    bool should_exit_position(const Position& position, 
                             const MarketDataPoint& current_data) override;
    
private:
    int fast_period_ = 10;
    int slow_period_ = 20;
    double position_size_pct_ = 0.1;
    
    std::vector<double> calculate_moving_average(const std::vector<double>& prices, int period);
    bool is_bullish_crossover(const std::vector<double>& fast_ma, 
                             const std::vector<double>& slow_ma);
    bool is_bearish_crossover(const std::vector<double>& fast_ma, 
                             const std::vector<double>& slow_ma);
};

// Exception classes
class BacktestException : public std::exception {
public:
    explicit BacktestException(const std::string& message) : message_(message) {}
    const char* what() const noexcept override { return message_.c_str(); }
    
private:
    std::string message_;
};

class InvalidConfigurationException : public BacktestException {
public:
    explicit InvalidConfigurationException(const std::string& message) 
        : BacktestException("Invalid Configuration: " + message) {}
};

class InsufficientDataException : public BacktestException {
public:
    explicit InsufficientDataException(const std::string& message) 
        : BacktestException("Insufficient Data: " + message) {}
};

class StrategyException : public BacktestException {
public:
    explicit StrategyException(const std::string& message) 
        : BacktestException("Strategy Error: " + message) {}
};

} // namespace backtest
} // namespace ats